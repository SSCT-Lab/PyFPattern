

def find_peaks(x, height=None, threshold=None, distance=None, prominence=None, width=None, wlen=None, rel_height=0.5, plateau_size=None):
    '\n    Find peaks inside a signal based on peak properties.\n\n    This function takes a one-dimensional array and finds all local maxima by\n    simple comparison of neighbouring values. Optionally, a subset of these\n    peaks can be selected by specifying conditions for a peak\'s properties.\n\n    Parameters\n    ----------\n    x : sequence\n        A signal with peaks.\n    height : number or ndarray or sequence, optional\n        Required height of peaks. Either a number, ``None``, an array matching\n        `x` or a 2-element sequence of the former. The first element is\n        always interpreted as the  minimal and the second, if supplied, as the\n        maximal required height.\n    threshold : number or ndarray or sequence, optional\n        Required threshold of peaks, the vertical distance to its neighbouring\n        samples. Either a number, ``None``, an array matching `x` or a\n        2-element sequence of the former. The first element is always\n        interpreted as the  minimal and the second, if supplied, as the maximal\n        required threshold.\n    distance : number, optional\n        Required minimal horizontal distance (>= 1) in samples between\n        neighbouring peaks. The removal order is explained in the notes section.\n    prominence : number or ndarray or sequence, optional\n        Required prominence of peaks. Either a number, ``None``, an array\n        matching `x` or a 2-element sequence of the former. The first\n        element is always interpreted as the  minimal and the second, if\n        supplied, as the maximal required prominence.\n    width : number or ndarray or sequence, optional\n        Required width of peaks in samples. Either a number, ``None``, an array\n        matching `x` or a 2-element sequence of the former. The first\n        element is always interpreted as the  minimal and the second, if\n        supplied, as the maximal required prominence.\n    wlen : int, optional\n        Used for calculation of the peaks prominences, thus it is only used if\n        one of the arguments `prominence` or `width` is given. See argument\n        `wlen` in `peak_prominences` for a full description of its effects.\n    rel_height : float, optional\n        Used for calculation of the peaks width, thus it is only used if `width`\n        is given. See argument  `rel_height` in `peak_widths` for a full\n        description of its effects.\n    plateau_size : number or ndarray or sequence, optional\n        Required size of the flat top of peaks in samples. Either a number,\n        ``None``, an array matching `x` or a 2-element sequence of the former.\n        The first element is always interpreted as the minimal and the second,\n        if supplied as the maximal required plateau size.\n\n        .. versionadded:: 1.2.0\n\n    Returns\n    -------\n    peaks : ndarray\n        Indices of peaks in `x` that satisfy all given conditions.\n    properties : dict\n        A dictionary containing properties of the returned peaks which were\n        calculated as intermediate results during evaluation of the specified\n        conditions:\n\n        * \'peak_heights\'\n              If `height` is given, the height of each peak in `x`.\n        * \'left_thresholds\', \'right_thresholds\'\n              If `threshold` is given, these keys contain a peaks vertical\n              distance to its neighbouring samples.\n        * \'peak_prominences\', \'right_bases\', \'left_bases\'\n              If `prominence` is given, these keys are accessible. See\n              `peak_prominences` for a description of their content.\n        * \'width_heights\', \'left_ips\', \'right_ips\'\n              If `width` is given, these keys are accessible. See `peak_widths`\n              for a description of their content.\n        * \'plateau_sizes\', left_edges\', \'right_edges\'\n              If `plateau_size` is given, these keys are accessible and contain\n              the indices of a peak\'s edges (edges are still part of the\n              plateau) and the calculated plateau sizes.\n\n              .. versionadded:: 1.2.0\n\n        To calculate and return properties without excluding peaks, provide the\n        open interval ``(None, None)`` as a value to the appropriate argument\n        (excluding `distance`).\n\n    Warns\n    -----\n    PeakPropertyWarning\n        Raised if a peak\'s properties have unexpected values (see\n        `peak_prominences` and `peak_widths`).\n\n    Warnings\n    --------\n    This function may return unexpected results for data containing NaNs. To\n    avoid this, NaNs should either be removed or replaced.\n\n    See Also\n    --------\n    find_peaks_cwt\n        Find peaks using the wavelet transformation.\n    peak_prominences\n        Directly calculate the prominence of peaks.\n    peak_widths\n        Directly calculate the width of peaks.\n\n    Notes\n    -----\n    In the context of this function, a peak or local maximum is defined as any\n    sample whose two direct neighbours have a smaller amplitude. For flat peaks\n    (more than one sample of equal amplitude wide) the index of the middle\n    sample is returned (rounded down in case the number of samples is even).\n    For noisy signals the peak locations can be off because the noise might\n    change the position of local maxima. In those cases consider smoothing the\n    signal before searching for peaks or use other peak finding and fitting\n    methods (like `find_peaks_cwt`).\n\n    Some additional comments on specifying conditions:\n\n    * Almost all conditions (excluding `distance`) can be given as half-open or\n      closed intervals, e.g ``1`` or ``(1, None)`` defines the half-open\n      interval :math:`[1, \\infty]` while ``(None, 1)`` defines the interval\n      :math:`[-\\infty, 1]`. The open interval ``(None, None)`` can be specified\n      as well, which returns the matching properties without exclusion of peaks.\n    * The border is always included in the interval used to select valid peaks.\n    * For several conditions the interval borders can be specified with\n      arrays matching `x` in shape which enables dynamic constrains based on\n      the sample position.\n    * The conditions are evalutated in the following order: `plateau_size`,\n      `height`, `threshold`, `distance`, `prominence`, `width`. In most cases\n      this order is the fastest one because faster operations are applied first\n      to reduce the number of peaks that need to be evaluated later.\n    * Satisfying the distance condition is accomplished by iterating over all\n      peaks in descending order based on their height and removing all lower\n      peaks that are too close.\n    * Use `wlen` to reduce the time it takes to evaluate the conditions for\n      `prominence` or `width` if `x` is large or has many local maxima\n      (see `peak_prominences`).\n\n    .. versionadded:: 1.1.0\n\n    Examples\n    --------\n    To demonstrate this function\'s usage we use a signal `x` supplied with\n    SciPy (see `scipy.misc.electrocardiogram`). Let\'s find all peaks (local\n    maxima) in `x` whose amplitude lies above 0.\n\n    >>> import matplotlib.pyplot as plt\n    >>> from scipy.misc import electrocardiogram\n    >>> from scipy.signal import find_peaks\n    >>> x = electrocardiogram()[2000:4000]\n    >>> peaks, _ = find_peaks(x, height=0)\n    >>> plt.plot(x)\n    >>> plt.plot(peaks, x[peaks], "x")\n    >>> plt.plot(np.zeros_like(x), "--", color="gray")\n    >>> plt.show()\n\n    We can select peaks below 0 with ``height=(None, 0)`` or use arrays matching\n    `x` in size to reflect a changing condition for different parts of the\n    signal.\n\n    >>> border = np.sin(np.linspace(0, 3 * np.pi, x.size))\n    >>> peaks, _ = find_peaks(x, height=(-border, border))\n    >>> plt.plot(x)\n    >>> plt.plot(-border, "--", color="gray")\n    >>> plt.plot(border, ":", color="gray")\n    >>> plt.plot(peaks, x[peaks], "x")\n    >>> plt.show()\n\n    Another useful condition for periodic signals can be given with the\n    `distance` argument. In this case we can easily select the positions of\n    QRS complexes within the electrocardiogram (ECG) by demanding a distance of\n    at least 150 samples.\n\n    >>> peaks, _ = find_peaks(x, distance=150)\n    >>> np.diff(peaks)\n    array([186, 180, 177, 171, 177, 169, 167, 164, 158, 162, 172])\n    >>> plt.plot(x)\n    >>> plt.plot(peaks, x[peaks], "x")\n    >>> plt.show()\n\n    Especially for noisy signals peaks can be easily grouped by their\n    prominence (see `peak_prominences`). E.g. we can select all peaks except\n    for the mentioned QRS complexes by limiting the allowed prominenence to 0.6.\n\n    >>> peaks, properties = find_peaks(x, prominence=(None, 0.6))\n    >>> properties["prominences"].max()\n    0.5049999999999999\n    >>> plt.plot(x)\n    >>> plt.plot(peaks, x[peaks], "x")\n    >>> plt.show()\n\n    And finally let\'s examine a different section of the ECG which contains\n    beat forms of different shape. To select only the atypical heart beats we\n    combine two conditions: a minimal prominence of 1 and width of at least 20\n    samples.\n\n    >>> x = electrocardiogram()[17000:18000]\n    >>> peaks, properties = find_peaks(x, prominence=1, width=20)\n    >>> properties["prominences"], properties["widths"]\n    (array([1.495, 2.3  ]), array([36.93773946, 39.32723577]))\n    >>> plt.plot(x)\n    >>> plt.plot(peaks, x[peaks], "x")\n    >>> plt.vlines(x=peaks, ymin=x[peaks] - properties["prominences"],\n    ...            ymax = x[peaks], color = "C1")\n    >>> plt.hlines(y=properties["width_heights"], xmin=properties["left_ips"],\n    ...            xmax=properties["right_ips"], color = "C1")\n    >>> plt.show()\n    '
    x = _arg_x_as_expected(x)
    if ((distance is not None) and (distance < 1)):
        raise ValueError('`distance` must be greater or equal to 1')
    (peaks, left_edges, right_edges) = _local_maxima_1d(x)
    properties = {
        
    }
    if (plateau_size is not None):
        plateau_sizes = ((right_edges - left_edges) + 1)
        (pmin, pmax) = _unpack_condition_args(plateau_size, x, peaks)
        keep = _select_by_property(plateau_sizes, pmin, pmax)
        peaks = peaks[keep]
        properties['plateau_sizes'] = plateau_sizes
        properties['left_edges'] = left_edges
        properties['right_edges'] = right_edges
        properties = {key: array[keep] for (key, array) in properties.items()}
    if (height is not None):
        peak_heights = x[peaks]
        (hmin, hmax) = _unpack_condition_args(height, x, peaks)
        keep = _select_by_property(peak_heights, hmin, hmax)
        peaks = peaks[keep]
        properties['peak_heights'] = peak_heights
        properties = {key: array[keep] for (key, array) in properties.items()}
    if (threshold is not None):
        (tmin, tmax) = _unpack_condition_args(threshold, x, peaks)
        (keep, left_thresholds, right_thresholds) = _select_by_peak_threshold(x, peaks, tmin, tmax)
        peaks = peaks[keep]
        properties['left_thresholds'] = left_thresholds
        properties['right_thresholds'] = right_thresholds
        properties = {key: array[keep] for (key, array) in properties.items()}
    if (distance is not None):
        keep = _select_by_peak_distance(peaks, x[peaks], distance)
        peaks = peaks[keep]
        properties = {key: array[keep] for (key, array) in properties.items()}
    if ((prominence is not None) or (width is not None)):
        wlen = _arg_wlen_as_expected(wlen)
        properties.update(zip(['prominences', 'left_bases', 'right_bases'], _peak_prominences(x, peaks, wlen=wlen)))
    if (prominence is not None):
        (pmin, pmax) = _unpack_condition_args(prominence, x, peaks)
        keep = _select_by_property(properties['prominences'], pmin, pmax)
        peaks = peaks[keep]
        properties = {key: array[keep] for (key, array) in properties.items()}
    if (width is not None):
        properties.update(zip(['widths', 'width_heights', 'left_ips', 'right_ips'], _peak_widths(x, peaks, rel_height, properties['prominences'], properties['left_bases'], properties['right_bases'])))
        (wmin, wmax) = _unpack_condition_args(width, x, peaks)
        keep = _select_by_property(properties['widths'], wmin, wmax)
        peaks = peaks[keep]
        properties = {key: array[keep] for (key, array) in properties.items()}
    return (peaks, properties)
