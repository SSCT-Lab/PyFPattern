

def adjusted_mutual_info_score(labels_true, labels_pred):
    "Adjusted Mutual Information between two clusterings.\n\n    Adjusted Mutual Information (AMI) is an adjustment of the Mutual\n    Information (MI) score to account for chance. It accounts for the fact that\n    the MI is generally higher for two clusterings with a larger number of\n    clusters, regardless of whether there is actually more information shared.\n    For two clusterings :math:`U` and :math:`V`, the AMI is given as::\n\n        AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\n    This metric is independent of the absolute values of the labels:\n    a permutation of the class or cluster label values won't change the\n    score value in any way.\n\n    This metric is furthermore symmetric: switching ``label_true`` with\n    ``label_pred`` will return the same score value. This can be useful to\n    measure the agreement of two independent label assignments strategies\n    on the same dataset when the real ground truth is not known.\n\n    Be mindful that this function is an order of magnitude slower than other\n    metrics, such as the Adjusted Rand Index.\n\n    Read more in the :ref:`User Guide <mutual_info_score>`.\n\n    Parameters\n    ----------\n    labels_true : int array, shape = [n_samples]\n        A clustering of the data into disjoint subsets.\n\n    labels_pred : array, shape = [n_samples]\n        A clustering of the data into disjoint subsets.\n\n    Returns\n    -------\n    ami: float(upperlimited by 1.0)\n       The AMI returns a value of 1 when the two partitions are identical\n       (ie perfectly matched). Random partitions (independent labellings) have\n       an expected AMI around 0 on average hence can be negative.\n\n    See also\n    --------\n    adjusted_rand_score: Adjusted Rand Index\n    mutual_information_score: Mutual Information (not adjusted for chance)\n\n    Examples\n    --------\n\n    Perfect labelings are both homogeneous and complete, hence have\n    score 1.0::\n\n      >>> from sklearn.metrics.cluster import adjusted_mutual_info_score\n      >>> adjusted_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])\n      1.0\n      >>> adjusted_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])\n      1.0\n\n    If classes members are completely split across different clusters,\n    the assignment is totally in-complete, hence the AMI is null::\n\n      >>> adjusted_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])\n      0.0\n\n    References\n    ----------\n    .. [1] `Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for\n       Clusterings Comparison: Variants, Properties, Normalization and\n       Correction for Chance, JMLR\n       <http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf>`_\n\n    .. [2] `Wikipedia entry for the Adjusted Mutual Information\n       <https://en.wikipedia.org/wiki/Adjusted_Mutual_Information>`_\n\n    "
    (labels_true, labels_pred) = check_clusterings(labels_true, labels_pred)
    n_samples = labels_true.shape[0]
    classes = np.unique(labels_true)
    clusters = np.unique(labels_pred)
    if ((classes.shape[0] == clusters.shape[0] == 1) or (classes.shape[0] == clusters.shape[0] == 0)):
        return 1.0
    contingency = contingency_matrix(labels_true, labels_pred, sparse=True)
    contingency = contingency.astype(np.float64)
    mi = mutual_info_score(labels_true, labels_pred, contingency=contingency)
    emi = expected_mutual_information(contingency, n_samples)
    (h_true, h_pred) = (entropy(labels_true), entropy(labels_pred))
    ami = ((mi - emi) / (max(h_true, h_pred) - emi))
    return ami
