

def non_negative_factorization(X, W=None, H=None, n_components=None, init='random', update_H=True, solver='cd', beta_loss='frobenius', tol=0.0001, max_iter=200, alpha=0.0, l1_ratio=0.0, regularization=None, random_state=None, verbose=0, shuffle=False):
    'Compute Non-negative Matrix Factorization (NMF)\n\n    Find two non-negative matrices (W, H) whose product approximates the non-\n    negative matrix X. This factorization can be used for example for\n    dimensionality reduction, source separation or topic extraction.\n\n    The objective function is::\n\n        0.5 * ||X - WH||_Fro^2\n        + alpha * l1_ratio * ||vec(W)||_1\n        + alpha * l1_ratio * ||vec(H)||_1\n        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2\n        + 0.5 * alpha * (1 - l1_ratio) * ||H||_Fro^2\n\n    Where::\n\n        ||A||_Fro^2 = \\sum_{i,j} A_{ij}^2 (Frobenius norm)\n        ||vec(A)||_1 = \\sum_{i,j} abs(A_{ij}) (Elementwise L1 norm)\n\n    For multiplicative-update (\'mu\') solver, the Frobenius norm\n    (0.5 * ||X - WH||_Fro^2) can be changed into another beta-divergence loss,\n    by changing the beta_loss parameter.\n\n    The objective function is minimized with an alternating minimization of W\n    and H. If H is given and update_H=False, it solves for W only.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        Constant matrix.\n\n    W : array-like, shape (n_samples, n_components)\n        If init=\'custom\', it is used as initial guess for the solution.\n\n    H : array-like, shape (n_components, n_features)\n        If init=\'custom\', it is used as initial guess for the solution.\n        If update_H=False, it is used as a constant, to solve for W only.\n\n    n_components : integer\n        Number of components, if n_components is not set all features\n        are kept.\n\n    init :  None | \'random\' | \'nndsvd\' | \'nndsvda\' | \'nndsvdar\' | \'custom\'\n        Method used to initialize the procedure.\n        Default: \'nndsvd\' if n_components < n_features, otherwise random.\n        Valid options:\n\n        - \'random\': non-negative random matrices, scaled with:\n            sqrt(X.mean() / n_components)\n\n        - \'nndsvd\': Nonnegative Double Singular Value Decomposition (NNDSVD)\n            initialization (better for sparseness)\n\n        - \'nndsvda\': NNDSVD with zeros filled with the average of X\n            (better when sparsity is not desired)\n\n        - \'nndsvdar\': NNDSVD with zeros filled with small random values\n            (generally faster, less accurate alternative to NNDSVDa\n            for when sparsity is not desired)\n\n        - \'custom\': use custom matrices W and H\n\n    update_H : boolean, default: True\n        Set to True, both W and H will be estimated from initial guesses.\n        Set to False, only W will be estimated.\n\n    solver : \'cd\' | \'mu\'\n        Numerical solver to use:\n        \'cd\' is a Coordinate Descent solver that uses Fast Hierarchical\n            Alternating Least Squares (Fast HALS).\n        \'mu\' is a Multiplicative Update solver.\n\n        .. versionadded:: 0.17\n           Coordinate Descent solver.\n\n        .. versionadded:: 0.19\n           Multiplicative Update solver.\n\n    beta_loss : float or string, default \'frobenius\'\n        String must be in {\'frobenius\', \'kullback-leibler\', \'itakura-saito\'}.\n        Beta divergence to be minimized, measuring the distance between X\n        and the dot product WH. Note that values different from \'frobenius\'\n        (or 2) and \'kullback-leibler\' (or 1) lead to significantly slower\n        fits. Note that for beta_loss <= 0 (or \'itakura-saito\'), the input\n        matrix X cannot contain zeros. Used only in \'mu\' solver.\n\n        .. versionadded:: 0.19\n\n    tol : float, default: 1e-4\n        Tolerance of the stopping condition.\n\n    max_iter : integer, default: 200\n        Maximum number of iterations before timing out.\n\n    alpha : double, default: 0.\n        Constant that multiplies the regularization terms.\n\n    l1_ratio : double, default: 0.\n        The regularization mixing parameter, with 0 <= l1_ratio <= 1.\n        For l1_ratio = 0 the penalty is an elementwise L2 penalty\n        (aka Frobenius Norm).\n        For l1_ratio = 1 it is an elementwise L1 penalty.\n        For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.\n\n    regularization : \'both\' | \'components\' | \'transformation\' | None\n        Select whether the regularization affects the components (H), the\n        transformation (W), both or none of them.\n\n    random_state : int, RandomState instance or None, optional, default: None\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : integer, default: 0\n        The verbosity level.\n\n    shuffle : boolean, default: False\n        If true, randomize the order of coordinates in the CD solver.\n\n    Returns\n    -------\n    W : array-like, shape (n_samples, n_components)\n        Solution to the non-negative least squares problem.\n\n    H : array-like, shape (n_components, n_features)\n        Solution to the non-negative least squares problem.\n\n    n_iter : int\n        Actual number of iterations.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.array([[1,1], [2, 1], [3, 1.2], [4, 1], [5, 0.8], [6, 1]])\n    >>> from sklearn.decomposition import non_negative_factorization\n    >>> W, H, n_iter = non_negative_factorization(X, n_components=2,\n    ... init=\'random\', random_state=0)\n\n    References\n    ----------\n    Cichocki, Andrzej, and P. H. A. N. Anh-Huy. "Fast local algorithms for\n    large scale nonnegative matrix and tensor factorizations."\n    IEICE transactions on fundamentals of electronics, communications and\n    computer sciences 92.3: 708-721, 2009.\n\n    Fevotte, C., & Idier, J. (2011). Algorithms for nonnegative matrix\n    factorization with the beta-divergence. Neural Computation, 23(9).\n    '
    X = check_array(X, accept_sparse=('csr', 'csc'), dtype=float)
    check_non_negative(X, 'NMF (input X)')
    beta_loss = _check_string_param(solver, regularization, beta_loss, init)
    if ((safe_min(X) == 0) and (beta_loss <= 0)):
        raise ValueError('When beta_loss <= 0 and X contains zeros, the solver may diverge. Please add small values to X, or use a positive beta_loss.')
    (n_samples, n_features) = X.shape
    if (n_components is None):
        n_components = n_features
    if ((not isinstance(n_components, INTEGER_TYPES)) or (n_components <= 0)):
        raise ValueError(('Number of components must be a positive integer; got (n_components=%r)' % n_components))
    if ((not isinstance(max_iter, INTEGER_TYPES)) or (max_iter < 0)):
        raise ValueError(('Maximum number of iterations must be a positive integer; got (max_iter=%r)' % max_iter))
    if ((not isinstance(tol, numbers.Number)) or (tol < 0)):
        raise ValueError(('Tolerance for stopping criteria must be positive; got (tol=%r)' % tol))
    if ((init == 'custom') and update_H):
        _check_init(H, (n_components, n_features), 'NMF (input H)')
        _check_init(W, (n_samples, n_components), 'NMF (input W)')
    elif (not update_H):
        _check_init(H, (n_components, n_features), 'NMF (input H)')
        if (solver == 'mu'):
            avg = np.sqrt((X.mean() / n_components))
            W = np.full((n_samples, n_components), avg)
        else:
            W = np.zeros((n_samples, n_components))
    else:
        (W, H) = _initialize_nmf(X, n_components, init=init, random_state=random_state)
    (l1_reg_W, l1_reg_H, l2_reg_W, l2_reg_H) = _compute_regularization(alpha, l1_ratio, regularization)
    if (solver == 'cd'):
        (W, H, n_iter) = _fit_coordinate_descent(X, W, H, tol, max_iter, l1_reg_W, l1_reg_H, l2_reg_W, l2_reg_H, update_H=update_H, verbose=verbose, shuffle=shuffle, random_state=random_state)
    elif (solver == 'mu'):
        (W, H, n_iter) = _fit_multiplicative_update(X, W, H, beta_loss, max_iter, tol, l1_reg_W, l1_reg_H, l2_reg_W, l2_reg_H, update_H, verbose)
    else:
        raise ValueError(("Invalid solver parameter '%s'." % solver))
    if ((n_iter == max_iter) and (tol > 0)):
        warnings.warn(('Maximum number of iteration %d reached. Increase it to improve convergence.' % max_iter), ConvergenceWarning)
    return (W, H, n_iter)
