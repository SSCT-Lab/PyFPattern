

def fixed_unigram_candidate_sampler(true_classes, num_true, num_sampled, unique, range_max, vocab_file='', distortion=1.0, num_reserved_ids=0, num_shards=1, shard=0, unigrams=(), seed=None, name=None):
    "Samples a set of classes using the provided (fixed) base distribution.\n\n  This operation randomly samples a tensor of sampled classes\n  (`sampled_candidates`) from the range of integers `[0, range_max)`.\n\n  The elements of `sampled_candidates` are drawn without replacement\n  (if `unique=True`) or with replacement (if `unique=False`) from\n  the base distribution.\n\n  The base distribution is read from a file or passed in as an\n  in-memory array. There is also an option to skew the distribution by\n  applying a distortion power to the weights.\n\n  In addition, this operation returns tensors `true_expected_count`\n  and `sampled_expected_count` representing the number of times each\n  of the target classes (`true_classes`) and the sampled\n  classes (`sampled_candidates`) is expected to occur in an average\n  tensor of sampled classes.  These values correspond to `Q(y|x)`\n  defined in [this\n  document](http://www.tensorflow.org/extras/candidate_sampling.pdf).\n  If `unique=True`, then these are post-rejection probabilities and we\n  compute them approximately.\n\n  Args:\n    true_classes: A `Tensor` of type `int64` and shape `[batch_size,\n      num_true]`. The target classes.\n    num_true: An `int`.  The number of target classes per training example.\n    num_sampled: An `int`.  The number of classes to randomly sample.\n    unique: A `bool`. Determines whether all sampled classes in a batch are\n      unique.\n    range_max: An `int`. The number of possible classes.\n    vocab_file: Each valid line in this file (which should have a CSV-like\n      format) corresponds to a valid word ID. IDs are in sequential order,\n      starting from num_reserved_ids. The last entry in each line is expected\n      to be a value corresponding to the count or relative probability. Exactly\n      one of `vocab_file` and `unigrams` needs to be passed to this operation.\n    distortion: The distortion is used to skew the unigram probability\n      distribution.  Each weight is first raised to the distortion's power\n      before adding to the internal unigram distribution. As a result,\n      `distortion = 1.0` gives regular unigram sampling (as defined by the vocab\n      file), and `distortion = 0.0` gives a uniform distribution.\n    num_reserved_ids: Optionally some reserved IDs can be added in the range\n      `[0, num_reserved_ids)` by the users. One use case is that a special\n      unknown word token is used as ID 0. These IDs will have a sampling\n      probability of 0.\n    num_shards: A sampler can be used to sample from a subset of the original\n      range in order to speed up the whole computation through parallelism. This\n      parameter (together with `shard`) indicates the number of partitions that\n      are being used in the overall computation.\n    shard: A sampler can be used to sample from a subset of the original range\n      in order to speed up the whole computation through parallelism. This\n      parameter (together with `num_shards`) indicates the particular partition\n      number of the operation, when partitioning is being used.\n    unigrams: A list of unigram counts or probabilities, one per ID in\n      sequential order. Exactly one of `vocab_file` and `unigrams` should be\n      passed to this operation.\n    seed: An `int`. An operation-specific seed. Default is 0.\n    name: A name for the operation (optional).\n\n  Returns:\n    sampled_candidates: A tensor of type `int64` and shape `[num_sampled]`.\n      The sampled classes.\n    true_expected_count: A tensor of type `float`.  Same shape as\n      `true_classes`. The expected counts under the sampling distribution\n      of each of `true_classes`.\n    sampled_expected_count: A tensor of type `float`. Same shape as\n      `sampled_candidates`. The expected counts under the sampling distribution\n      of each of `sampled_candidates`.\n\n  "
    (seed1, seed2) = random_seed.get_seed(seed)
    return gen_candidate_sampling_ops._fixed_unigram_candidate_sampler(true_classes, num_true, num_sampled, unique, range_max, vocab_file=vocab_file, distortion=distortion, num_reserved_ids=num_reserved_ids, num_shards=num_shards, shard=shard, unigrams=unigrams, seed=seed1, seed2=seed2, name=name)
