def frac_bilinear_upsampling(input, frac_ratio):
    'Compute bilinear upsampling\n    This function will build the symbolic graph for upsampling\n    a tensor by the given ratio using bilinear interpolation.\n\n    Parameters\n    ----------\n    input: symbolic 4D tensor\n        mini-batch of feature map stacks, of shape (batch size,\n        input channels, input rows, input columns) that will be upsampled.\n    frac_ratio: tuple of int or tuple of tuples of int\n        The tuple defining the fractional ratio by which the input is\n        upsampled in the 2D space. One fractional ratio should be\n        represented as (numerator, denominator). If row and col ratios are\n        different frac_ratio should be a tuple of fractional ratios, i.e\n        a tuple of tuples.\n    Returns\n    -------\n    symbolic 4D tensor\n        set of feature maps generated by bilinear upsampling. Tensor\n        is of shape (batch size, num_input_channels, input row size * row ratio,\n        input column size * column ratio). Each of these ratios can be fractional.\n    Notes\n    -----\n    :note: The kernel used for bilinear interpolation is fixed (not learned).\n    :note: When the upsampling frac_ratio numerator is even, the\n        last row and column is repeated one extra time compared to the first\n        row and column which makes the upsampled tensor asymmetrical on both\n        sides. This does not happen when it is odd.\n    '
    T = theano.tensor
    (row, col) = input.shape[2:]
    up_input = input.reshape(((- 1), 1, row, col))
    if (not isinstance(frac_ratio, tuple)):
        raise ValueError('frac_ratio must be a tuple')
    elif isinstance(frac_ratio[0], tuple):
        f_r = []
        for (i, fr) in enumerate(frac_ratio):
            (p, q) = fr
            div = gcd(p, q)
            f_r.append(tuple((np.array(fr) // div)))
        frac_ratio = tuple(f_r)
        ratio = (frac_ratio[0][0], frac_ratio[1][0])
        subsample = (frac_ratio[0][1], frac_ratio[1][1])
    else:
        (p, q) = frac_ratio
        div = gcd(p, q)
        frac_ratio = tuple((np.array(frac_ratio) // div))
        ratio = (frac_ratio[0], frac_ratio[0])
        subsample = (frac_ratio[1], frac_ratio[1])
    concat_mat = T.concatenate((up_input[:, :, :1, :], up_input, up_input[:, :, (- 1):, :]), axis=2)
    concat_mat = T.concatenate((concat_mat[:, :, :, :1], concat_mat, concat_mat[:, :, :, (- 1):]), axis=3)
    double_pad = ((((2 * T.as_tensor([row, col])) - 1) * np.array(ratio)) + 1)
    pad = (double_pad // 2)
    kern = bilinear_kernel_2D(ratio=ratio)[np.newaxis, np.newaxis, :, :].astype(theano.config.floatX)
    pad_kern = T.concatenate((T.zeros((tuple(kern.shape[:2]) + (pad[0], kern.shape[(- 1)])), dtype=theano.config.floatX), kern, T.zeros((tuple(kern.shape[:2]) + ((double_pad[0] - pad[0]), kern.shape[(- 1)])), dtype=theano.config.floatX)), axis=2)
    pad_kern = T.concatenate((T.zeros((tuple(pad_kern.shape[:3]) + (pad[1],)), dtype=theano.config.floatX), pad_kern, T.zeros((tuple(pad_kern.shape[:3]) + ((double_pad[1] - pad[1]),)), dtype=theano.config.floatX)), axis=3)
    upsamp = T.nnet.conv2d(pad_kern, concat_mat, border_mode='valid', filter_dilation=ratio, subsample=subsample)
    return upsamp.reshape((input.shape[0], input.shape[1], upsamp.shape[2], upsamp.shape[3]))