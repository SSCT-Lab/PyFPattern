def while_loop(cond, body, loop_vars, shape_invariants=None, parallel_iterations=10, back_prop=True, swap_memory=False, name=None):
    "Repeat `body` while the condition `cond` is true.\n\n  `cond` is a callable returning a boolean scalar tensor. `body` is a callable\n  returning a (possibly nested) tuple, namedtuple or list of tensors of the same\n  arity (length and structure) and types as `loop_vars`. `loop_vars` is a\n  (possibly nested) tuple, namedtuple or list of tensors that is passed to both\n  `cond` and `body`. `cond` and `body` both take as many arguments as there are\n  `loop_vars`.\n\n  While `cond` evaluates to true, `body` is executed.\n\n  In addition to regular Tensors or IndexedSlices, the body may accept and\n  return TensorArray objects.  The flows of the TensorArray objects will\n  be appropriately forwarded between loops and during gradient calculations.\n\n  For correctness, `tf.while_loop()` strictly enforces shape invariants for\n  the loop variables. A shape invariant is a (possibly partial) shape that\n  is unchanged across the iterations of the loop. An error will be raised\n  if the shape of a loop variable after an iteration is determined to be more\n  general than or incompatible with its shape invariant. For example, a shape\n  of [11, None] is more general than a shape of [11, 17], and [11, 21] is not\n  compatible with [11, 17]. By default (if the argument `shape_invariants` is\n  not specified), it is assumed that the initial shape of each tensor in\n  `loop_vars` is the same in every iteration. The `shape_invariants` argument\n  allows the caller to specify a less specific shape invariant for each loop\n  variable, which is needed if the shape varies between iterations. The\n  @{tf.Tensor.set_shape}\n  function may also be used in the `body` function to indicate that\n  the output loop variable has a particular shape. The shape invariant for\n  SparseTensor and IndexedSlices are treated specially as follows:\n\n  a) If a loop variable is a SparseTensor, the shape invariant must be\n  TensorShape([r]) where r is the rank of the dense tensor represented\n  by the sparse tensor. It means the shapes of the three tensors of the\n  SparseTensor are ([None], [None, r], [r]). NOTE: The shape invariant here\n  is the shape of the SparseTensor.dense_shape property. It must be the shape of\n  a vector.\n\n  b) If a loop variable is an IndexedSlices, the shape invariant must be\n  a shape invariant of the values tensor of the IndexedSlices. It means\n  the shapes of the three tensors of the IndexedSlices are (shape, [shape[0]],\n  [shape.ndims]).\n\n  `while_loop` implements non-strict semantics, enabling multiple iterations\n  to run in parallel. The maximum number of parallel iterations can be\n  controlled by `parallel_iterations`, which gives users some control over\n  memory consumption and execution order. For correct programs, `while_loop`\n  should return the same result for any parallel_iterations > 0.\n\n  For training, TensorFlow remembers the tensors that are produced in the\n  forward inference but needed in back propagation. These tensors can be a\n  main source of memory consumption and often cause OOM problems when training\n  on GPUs.  When the flag swap_memory is true, we swap out these tensors from\n  GPU to CPU.  This for example allows us to train RNN models with very long\n  sequences and large batches.\n\n  Args:\n    cond: A callable that represents the termination condition of the loop.\n    body: A callable that represents the loop body.\n    loop_vars: A (possibly nested) tuple, namedtuple or list of numpy array,\n      `Tensor`, and `TensorArray` objects.\n    shape_invariants: The shape invariants for the loop variables.\n    parallel_iterations: The number of iterations allowed to run in parallel.\n      It must be a positive integer.\n    back_prop: Whether backprop is enabled for this while loop.\n    swap_memory: Whether GPU-CPU memory swap is enabled for this loop.\n    name: Optional name prefix for the returned tensors.\n\n  Returns:\n    The output tensors for the loop variables after the loop. When the length\n    of `loop_vars` is 1 this is a Tensor, TensorArray or IndexedSlice and when\n    the length of `loop_vars` is greater than 1 it returns a list.\n\n  Raises:\n    TypeError: if `cond` or `body` is not callable.\n    ValueError: if `loop_vars` is empty.\n\n  Example:\n\n    ```python\n    i = tf.constant(0)\n    c = lambda i: tf.less(i, 10)\n    b = lambda i: tf.add(i, 1)\n    r = tf.while_loop(c, b, [i])\n    ```\n\n  Example with nesting and a namedtuple:\n\n    ```python\n    import collections\n    Pair = collections.namedtuple('Pair', 'j, k')\n    ijk_0 = (tf.constant(0), Pair(tf.constant(1), tf.constant(2)))\n    c = lambda i, p: i < 10\n    b = lambda i, p: (i + 1, Pair((p.j + p.k), (p.j - p.k)))\n    ijk_final = tf.while_loop(c, b, ijk_0)\n    ```\n\n  Example using shape_invariants:\n\n    ```python\n    i0 = tf.constant(0)\n    m0 = tf.ones([2, 2])\n    c = lambda i, m: i < 10\n    b = lambda i, m: [i+1, tf.concat([m, m], axis=0)]\n    tf.while_loop(\n        c, b, loop_vars=[i0, m0],\n        shape_invariants=[i0.get_shape(), tf.TensorShape([None, 2])])\n    ```\n\n  "
    with ops.name_scope(name, 'while', loop_vars) as name:
        if (not loop_vars):
            raise ValueError('No loop variables provided')
        if (not callable(cond)):
            raise TypeError('cond must be callable.')
        if (not callable(body)):
            raise TypeError('body must be callable.')
        if (parallel_iterations < 1):
            raise TypeError('parallel_iterations must be a positive integer.')
        if (shape_invariants is not None):
            nest.assert_same_structure(loop_vars, shape_invariants)
        context = WhileContext(parallel_iterations, back_prop, swap_memory, name)
        ops.add_to_collection(ops.GraphKeys.WHILE_CONTEXT, context)
        result = context.BuildLoop(cond, body, loop_vars, shape_invariants)
        return result