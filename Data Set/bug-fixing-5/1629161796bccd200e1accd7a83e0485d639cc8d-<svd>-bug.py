@tf_export('svd', 'linalg.svd')
def svd(tensor, full_matrices=False, compute_uv=True, name=None):
    'Computes the singular value decompositions of one or more matrices.\n\n  Computes the SVD of each inner matrix in `tensor` such that\n  `tensor[..., :, :] = u[..., :, :] * diag(s[..., :, :]) *\n   transpose(conj(v[..., :, :]))`\n\n  ```python\n  # a is a tensor.\n  # s is a tensor of singular values.\n  # u is a tensor of left singular vectors.\n  # v is a tensor of right singular vectors.\n  s, u, v = svd(a)\n  s = svd(a, compute_uv=False)\n  ```\n\n  Args:\n    tensor: `Tensor` of shape `[..., M, N]`. Let `P` be the minimum of `M` and\n      `N`.\n    full_matrices: If true, compute full-sized `u` and `v`. If false\n      (the default), compute only the leading `P` singular vectors.\n      Ignored if `compute_uv` is `False`.\n    compute_uv: If `True` then left and right singular vectors will be\n      computed and returned in `u` and `v`, respectively. Otherwise, only the\n      singular values will be computed, which can be significantly faster.\n    name: string, optional name of the operation.\n\n  Returns:\n    s: Singular values. Shape is `[..., P]`. The values are sorted in reverse\n      order of magnitude, so s[..., 0] is the largest value, s[..., 1] is the\n      second largest, etc.\n    u: Left singular vectors. If `full_matrices` is `False` (default) then\n      shape is `[..., M, P]`; if `full_matrices` is `True` then shape is\n      `[..., M, M]`. Not returned if `compute_uv` is `False`.\n    v: Right singular vectors. If `full_matrices` is `False` (default) then\n      shape is `[..., N, P]`. If `full_matrices` is `True` then shape is\n      `[..., N, N]`. Not returned if `compute_uv` is `False`.\n\n  @compatibility(numpy)\n  Mostly equivalent to numpy.linalg.svd, except that\n    * The order of output  arguments here is `s`, `u`, `v` when `compute_uv` is\n      `True`, as opposed to `u`, `s`, `v` for numpy.linalg.svd.\n    * full_matrices is `False` by default as opposed to `True` for\n       numpy.linalg.svd.\n    * tf.linalg.svd uses the standard definition of the SVD\n      \\\\(A = U \\Sigma V^H\\\\), such that the left singular vectors of `a` are\n      the columns of `u`, while the right singular vectors of `a` are the\n      columns of `v`. On the other hand, numpy.linalg.svd returns the adjoint\n      \\\\(V^H\\\\) as the third output argument.\n  ```python\n  import tensorflow as tf\n  import numpy as np\n  s, u, v = tf.linalg.svd(a)\n  tf_a_approx = tf.matmul(u, tf.matmul(tf.linalg.diag(s), v, adjoint_v=True))\n  u, s, v_adj = np.linalg.svd(a, full_matrices=False)\n  np_a_approx = np.dot(u, np.dot(np.diag(s), v_adj))\n  # tf_a_approx and np_a_approx should be numerically close.\n  ````\n  @end_compatibility\n  '
    (s, u, v) = gen_linalg_ops.svd(tensor, compute_uv=compute_uv, full_matrices=full_matrices, name=name)
    if compute_uv:
        return (math_ops.real(s), u, v)
    else:
        return math_ops.real(s)