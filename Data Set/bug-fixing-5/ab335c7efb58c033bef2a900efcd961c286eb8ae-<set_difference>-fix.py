@tf_export('sets.set_difference')
def set_difference(a, b, aminusb=True, validate_indices=True):
    'Compute set difference of elements in last dimension of `a` and `b`.\n\n  All but the last dimension of `a` and `b` must match.\n\n  Example:\n\n  ```python\n    import tensorflow as tf\n    import collections\n\n    # Represent the following array of sets as a sparse tensor:\n    # a = np.array([[{1, 2}, {3}], [{4}, {5, 6}]])\n    a = collections.OrderedDict([\n        ((0, 0, 0), 1),\n        ((0, 0, 1), 2),\n        ((0, 1, 0), 3),\n        ((1, 0, 0), 4),\n        ((1, 1, 0), 5),\n        ((1, 1, 1), 6),\n    ])\n    a = tf.SparseTensor(list(a.keys()), list(a.values()), dense_shape=[2, 2, 2])\n\n    # np.array([[{1, 3}, {2}], [{4, 5}, {5, 6, 7, 8}]])\n    b = collections.OrderedDict([\n        ((0, 0, 0), 1),\n        ((0, 0, 1), 3),\n        ((0, 1, 0), 2),\n        ((1, 0, 0), 4),\n        ((1, 0, 1), 5),\n        ((1, 1, 0), 5),\n        ((1, 1, 1), 6),\n        ((1, 1, 2), 7),\n        ((1, 1, 3), 8),\n    ])\n    b = tf.SparseTensor(list(b.keys()), list(b.values()), dense_shape=[2, 2, 4])\n\n    # `set_difference` is applied to each aligned pair of sets.\n    tf.sets.set_difference(a, b)\n\n    # The result will be equivalent to either of:\n    #\n    # np.array([[{2}, {3}], [{}, {}]])\n    #\n    # collections.OrderedDict([\n    #     ((0, 0, 0), 2),\n    #     ((0, 1, 0), 3),\n    # ])\n  ```\n\n  Args:\n    a: `Tensor` or `SparseTensor` of the same type as `b`. If sparse, indices\n        must be sorted in row-major order.\n    b: `Tensor` or `SparseTensor` of the same type as `a`. If sparse, indices\n        must be sorted in row-major order.\n    aminusb: Whether to subtract `b` from `a`, vs vice versa.\n    validate_indices: Whether to validate the order and range of sparse indices\n       in `a` and `b`.\n\n  Returns:\n    A `SparseTensor` whose shape is the same rank as `a` and `b`, and all but\n    the last dimension the same. Elements along the last dimension contain the\n    differences.\n  '
    (a, b, flipped) = _convert_to_tensors_or_sparse_tensors(a, b)
    if flipped:
        aminusb = (not aminusb)
    return _set_operation(a, b, ('a-b' if aminusb else 'b-a'), validate_indices)