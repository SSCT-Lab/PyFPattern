def dst(x, type=2, n=None, axis=(- 1), norm=None, overwrite_x=False):
    '\n    Return the Discrete Sine Transform of arbitrary type sequence x.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    type : {1, 2, 3, 4}, optional\n        Type of the DST (see Notes). Default type is 2.\n    n : int, optional\n        Length of the transform.  If ``n < x.shape[axis]``, `x` is\n        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The\n        default results in ``n = x.shape[axis]``.\n    axis : int, optional\n        Axis along which the dst is computed; the default is over the\n        last axis (i.e., ``axis=-1``).\n    norm : {None, \'ortho\'}, optional\n        Normalization mode (see Notes). Default is None.\n    overwrite_x : bool, optional\n        If True, the contents of `x` can be destroyed; the default is False.\n\n    Returns\n    -------\n    dst : ndarray of reals\n        The transformed input array.\n\n    See Also\n    --------\n    idst : Inverse DST\n\n    Notes\n    -----\n    For a single dimension array ``x``.\n\n    There are theoretically 8 types of the DST for different combinations of\n    even/odd boundary conditions and boundary off sets [1]_, only the first\n    4 types are implemented in scipy.\n\n    **Type I**\n\n    There are several definitions of the DST-I; we use the following\n    for ``norm=None``.  DST-I assumes the input is odd around n=-1 and n=N. ::\n\n                 N-1\n      y[k] = 2 * sum x[n]*sin(pi*(k+1)*(n+1)/(N+1))\n                 n=0\n\n    Note that the DST-I is only supported for input size > 1\n    The (unnormalized) DST-I is its own inverse, up to a factor `2(N+1)`.\n    The orthonormalized DST-I is exactly its own inverse.\n\n    **Type II**\n\n    There are several definitions of the DST-II; we use the following\n    for ``norm=None``.  DST-II assumes the input is odd around n=-1/2 and\n    n=N-1/2; the output is odd around k=-1 and even around k=N-1 ::\n\n                N-1\n      y[k] = 2* sum x[n]*sin(pi*(k+1)*(n+0.5)/N), 0 <= k < N.\n                n=0\n\n    if ``norm=\'ortho\'``, ``y[k]`` is multiplied by a scaling factor `f` ::\n\n        f = sqrt(1/(4*N)) if k == 0\n        f = sqrt(1/(2*N)) otherwise.\n\n    **Type III**\n\n    There are several definitions of the DST-III, we use the following\n    (for ``norm=None``).  DST-III assumes the input is odd around n=-1\n    and even around n=N-1 ::\n\n                                 N-2\n      y[k] = x[N-1]*(-1)**k + 2* sum x[n]*sin(pi*(k+0.5)*(n+1)/N), 0 <= k < N.\n                                 n=0\n\n    The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up\n    to a factor `2N`.  The orthonormalized DST-III is exactly the inverse of\n    the orthonormalized DST-II.\n\n    .. versionadded:: 0.11.0\n\n    **Type IV**\n\n    There are several definitions of the DST-IV, we use the following\n    (for ``norm=None``).  DST-IV assumes the input is odd around n=-0.5\n    and even around n=N-0.5 ::\n\n                N-1\n      y[k] = 2* sum x[n]*sin(pi*(k+0.5)*(n+0.5)/N), 0 <= k < N.\n                n=0\n\n    The (unnormalized) DST-IV is its own inverse, up\n    to a factor `2N`.  The orthonormalized DST-IV is exactly its own inverse.\n\n    .. versionadded:: 1.2.0\n       Support for DST-IV.\n\n    References\n    ----------\n    .. [1] Wikipedia, "Discrete sine transform",\n           https://en.wikipedia.org/wiki/Discrete_sine_transform\n\n    '
    return _dst(x, type, n, axis, normalize=norm, overwrite_x=overwrite_x)